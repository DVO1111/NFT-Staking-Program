# Proof of Concept: Division by Zero Vulnerability

## Vulnerability Summary
A malicious or careless staking pool creator can permanently lock all staked NFTs by calling `change_reward` at the exact moment when `current_time == staking_ends_at`.

## Attack Steps

### Prerequisites
- Staking pool exists with active stakers
- Creator has authority to call `change_reward`

### Exploitation
```
1. Wait until clock.unix_timestamp == stake_details.staking_ends_at
2. Call change_reward(new_amount)
3. This sets reward_change_time.last() = staking_ends_at
4. Any subsequent unstake/claim calls update_staked_weight()
5. update_staked_weight calculates: base = staking_ends_at - last_reward_time = 0
6. Division by zero causes transaction failure
7. All NFTs permanently locked in contract
```

### Simulated Test Case
```rust
#[test]
fn test_division_by_zero_exploit() {
    // Setup: Create staking pool ending at time T
    let staking_ends_at = 1000;
    let mut stake_details = create_stake_details(staking_ends_at);
    
    // User stakes NFT
    stake_details.update_staked_weight(500, true).unwrap();
    
    // EXPLOIT: Creator calls change_reward exactly at end time
    let exploit_time = staking_ends_at; // current_time == staking_ends_at
    stake_details.change_reward(200, exploit_time);
    // Now: reward_change_time.last() == staking_ends_at
    
    // IMPACT: User tries to unstake - FAILS with division by zero
    // base = staking_ends_at - last_reward_time = 1000 - 1000 = 0
    let result = stake_details.update_staked_weight(exploit_time, false);
    assert!(result.is_err()); // Division by zero!
    
    // User's NFT is now PERMANENTLY LOCKED
}
```

### Vulnerable Code Path
```
change_reward (current_time == staking_ends_at)
    └── require_gte!(staking_ends_at, current_time) ✓ passes (1000 >= 1000)
    └── stake_details.change_reward(new_reward, current_time)
        └── reward_change_time.push(current_time) // Now equals staking_ends_at

unstake/claim
    └── update_staked_weight(...)
        └── base = staking_ends_at - last_reward_time = 0
        └── weight = num / base  // DIVISION BY ZERO
        └── TRANSACTION FAILS

NFTs cannot be withdrawn -> PERMANENT LOCK
```

## Fix Applied

### Primary Fix (change_reward.rs)
```diff
-    require_gte!(staking_ends_at, current_time, StakeError::StakingIsOver);
+    // FIX: Use strict greater-than to prevent division by zero
+    require_gt!(staking_ends_at, current_time, StakeError::StakingIsOver);
```

### Defense-in-Depth (stake_details.rs)
```diff
     let base = self.staking_ends_at
         .checked_sub(last_reward_time)
         .ok_or(StakeError::ProgramSubError)? as u128;
+
+    // FIX: Defense-in-depth guard against division by zero
+    require!(base > 0, StakeError::ProgramDivError);
```

## Severity: CRITICAL
- **Impact**: Total loss of staked assets (NFTs permanently locked)
- **Likelihood**: Requires specific timing but trivially exploitable
- **Exploitability**: Single transaction, no special tools needed
